"""Contains the class Table, which generates synthetic data from real data contained in a standard pandas dataframe.
"""

import gc

import pandas as pd

from .BasicTable import BasicTable

from .columns.NumericalVariable import NumericalVariable
from .columns.CategoricalVariable import CategoricalVariable
from .columns.DatetimeVariable import DatetimeVariable
from .columns.EmptyVariable import EmptyVariable
from .columns.StringVariable import StringVariable

class Table(BasicTable):
    """ Subclass extending BasicTable. This contains methods for producing a dataframe of synthetic data from a dataframe of real data.
    
        Public methods:
            __init__: Constructor. Extends BasicTable.__init__().
            analyse: Uses heuristics to automatically determine the column type.  Overrides BasicTable.analyse().
            analyse_with_column_list: Specify column types using a list of dictionaries.
            generate: Use to generate a table containing SD.  Only use after invoking Table.analyse(), Table.analyse_with_column_list(), or Table.read_in_table(). Overrides BasicTable.generate().
            dictionary_out: Outputs a dictionary containing summary statistics of each table column.  Only use after invoking Table.analyse(), Table.analyse_with_column_list(), or Table.read_in_table(). Overrides BasicTable.dictionary_out().
            read_in_table: Reads in a table definition generated by Table.dictionary_out().
            delete_table: Mark real data in dataframe for deletion and call garbage collector.  Inherited from BasicTable.
            identify_variable_type: Contains heuristics used in automatically detecting column types. Inherited from BasicTable.   
    """
    
    def __init__(self, table: pd.DataFrame, table_name: str):
        """Public method. Constructor that initialises the Table object.
        
        Passes table data and table name to the superclass, defines the table type as 'normal_table'.
        
        Extends BasicTable.__init__().

        Args:
            table (pandas.DataFrame): The dataframe to be analysed.  If the intention is to generate a synthetic data table from an output dictionary using Table.read_in_table(), then this dataframe should be empty.
            table_name (str): The name of the table.
        """
        
        super().__init__(table, table_name, 'normal_table')
        
    def analyse(self, decimal_accuracy: int):
        """Public method. This uses a set of preset heuristics in order to automatically determine the nature and properties of each column.
        
        Each column in turn is subjected to the heuristics, which return a VariableType subclass instance corresponding to the column type.  The subclass analyse() method is called and the instance added to a list of column VariableType subclass instances that when complete corresponds to each column.
        
        Overrides BasicTable.analyse().

        Args:
            decimal_accuracy (int): Number of decimal places to use in numerical data columns.
        """
        
        self.column_types = []
        for column in self.table.columns:
            column_type = super().identify_variable_type(column, decimal_accuracy)
            column_type.analyse()
            self.column_types.append(column_type)
            
    def generate(self, new_column_length: int) -> pd.DataFrame:
        """Public method.   Generates synthetic data based on the table properties provided by analysis or input methods. Note that the garbage collector is called by this method.  Only call after invoking Table.analyse(), Table.analyse_with_column_list(), or Table.read_in_table().
        
        For each column in the list of VariableType subclasses provided by Table.analyse(), Table.analyse_with_column_list(), or Table.read_in_table(), generate a pandas Series of synthetic data, append it column-wise to a new Dataframe, mark the data for deletion and call the garbage collector.
        
        Overrides BasicTable.generate().

        Args:
            new_column_length (int): number of rows in each column.

        Returns:
            pandas.DataFrame: A dataframe containing the synthetic data.
        """
        
        new_table = pd.DataFrame()
        for column in self.column_types:
            column_data = column.generate(new_column_length)
            new_table[column_data.name] = column_data
            del [[column_data]]
            gc.collect()
            
        return new_table
    
    def dictionary_out(self) -> dict:
        """Public method. Outputs the current table properties provided by analysis or input methods. Only call after invoking Table.analyse(), Table.analyse_with_column_list(), or Table.read_in_table().
        
        Sets general table properties, then for each entry in the list of column types calls its dictionary_out method and inserts this into the output dictionary.
        
        Overrides BasicTable.dictionary_out().

        Returns:
            dict: dictionary summary of the table properties.
        """
        
        dictionary = {
            "Table_name": self.TABLE_NAME,
            "Table_type": self.TABLE_TYPE,
            "Number_of_rows": self.TABLE_ROWS,
            "Column_details" : []
            }
        
        for column in self.column_types:
            dictionary["Column_details"].append(column.dictionary_out())
            
        return dictionary
    
    def read_in_table(self,table_definition: dict):
        """Public method. Reads in a dictionary containing the table summary statistics.
        
        For each column, a VariableType subclass of the appropriate type containing properties taken from the input is created and appended to a list of columns.

        Args:
            table_definition (dict): Dictionary containing the table specification.

        Raises:
            ValueError: The pattern value for a text column is neither True nor False.
            ValueError: The type of a column is not one of the allowed types.
        """
        
        self.TABLE_NAME = table_definition["Table_name"]
        self.TABLE_TYPE = table_definition["Table_type"]
        self.TABLE_ROWS = table_definition["Number_of_rows"]
        
        def to_Bool(value):
            if isinstance(value, str):
                if value.strip() == 'True':
                    return True
                elif value.strip() == 'False':
                    return False
                else:
                    return value
            else:
                return value
        
        # note that for this to work we have to enter an empty Series into the column variable constructor.
        self.column_types = [] 
        for column in table_definition["Column_details"]:
            temp_column = pd.Series()
            match column['Type']:
                case 'empty':
                    temp_column = EmptyVariable(pd.Series([0], name=column["Name"]))
                case 'numeric':
                    temp_column = NumericalVariable(
                        pd.Series([0], name=column['Name']),
                        decimal_precision = column['decimal_precision'],
                        average_min_max = to_Bool(column['averaged_max_and_min']),
                        )
                    temp_column.set(
                        mean = column['mean'],
                        standard_deviation = column['standard_deviation'],
                        maximum = column['maximum'],
                        minimum = column['minimum'],
                        is_integer = to_Bool(column['is_integer']),
                        no_vals_in_threshold = column['# of values in average_max_min'],
                        missing_freq = column["missing_value_freq"],
                        number_of_rows = self.TABLE_ROWS
                    )
                case 'categorical':
                    temp_column = CategoricalVariable(pd.Series([0], name = column["Name"]))
                    temp_column.set(
                        {value: column[value] for value in column.keys() if value not in ['Type','Name']}
                    )
                case 'date':
                    if column['format']:
                        temp_column = DatetimeVariable(
                            pd.Series([0], name = column["Name"]), 
                            average_min_max=to_Bool(column['averaged_max_and_min']), 
                            date_format=column['format']
                            )
                    else:
                        temp_column = DatetimeVariable(
                            pd.Series([0], name = column["Name"]),
                            average_min_max=to_Bool(column['averaged_max_and_min'])
                        )
                    temp_column.set(
                        type = column['Type'],
                        earliest = column["earliest"],
                        latest = column["latest"],
                        missing_freq = column["missing_value_freq"],
                        number_of_rows = self.TABLE_ROWS,
                        no_vals_in_threshold = column['# of values in average_max_min']
                    )
                case 'datetime':
                    if column['format']:
                        temp_column = DatetimeVariable(
                            pd.Series([0], name = column["Name"]), 
                            average_min_max=to_Bool(column['averaged_max_and_min']), 
                            datetime_format=column['format']
                            )
                    else:
                        temp_column = DatetimeVariable(
                            pd.Series([0], name = column["Name"]), 
                            average_min_max=to_Bool(column['averaged_max_and_min'])
                            )
                    temp_column.set(
                        type = column['Type'],
                        earliest = column["earliest"],
                        latest = column["latest"],
                        missing_freq = column["missing_value_freq"],
                        number_of_rows = self.TABLE_ROWS,
                        no_vals_in_threshold = column['# of values in average_max_min']
                    )                   
                case 'time':
                    if column['format']:
                        temp_column = DatetimeVariable(
                            pd.Series([0], name = column["Name"]), 
                            average_min_max=to_Bool(column['averaged_max_and_min']), 
                            time_format=column['format']
                            )
                    else:
                        temp_column = DatetimeVariable(
                            pd.Series([0], name = column["Name"]),
                            average_min_max=to_Bool(column['averaged_max_and_min'])
                            )
                    temp_column.set(
                        type = column['Type'],
                        earliest = column["earliest"],
                        latest = column["latest"],
                        missing_freq = column["missing_value_freq"],
                        number_of_rows = self.TABLE_ROWS,
                        no_vals_in_threshold = column['# of values in average_max_min']
                    )
                case 'text':
                    temp_column = StringVariable(pd.Series([0], name = column["Name"]))
                    if to_Bool(column['Pattern'])==True:
                        temp_column.set_pattern(
                            pattern = to_Bool(column["Pattern"]),
                            character_frequencies = {value: column[value] for value in column if "character_number_" in value},
                            max_length = column["Max_length"],
                            missing_freq = column["missing_value_freq"],
                            number_of_rows = self.TABLE_ROWS
                        )
                    elif to_Bool(column['Pattern'])==False:
                        temp_column.set_no_pattern(
                            pattern = to_Bool(column["Pattern"]),
                            min_length = column["Min_length"],
                            max_length = column["Max_length"],
                            missing_freq = column["missing_value_freq"],
                            number_of_rows = self.TABLE_ROWS
                        )
                    else:
                        raise ValueError(f"Pattern value in column {column['Name']} is neither true or false.")
                case _:
                    raise ValueError(f"Type of column {column['Name']} is {column['Type']}: this is not an allowed value.")
                
            self.column_types.append(temp_column)
    
    def analyse_with_column_list(self, columns_list: list[dict]) :
        """Public method. Analyses columns according to how their type is described in the input list.
        
        For each column, a VariableType subclass corresponding to the one defined in the input is created, its analyse method invoked, and added to a list corresponding to the table columns.

        Args:
            columns_list (list[dict]): List of dictionaries. Each dictionary describes a column type and sets associated variables, if any.
        """
        
        self.column_types = []
        for i, column in enumerate(self.table.columns):
            column_type = self.__assign_variable_type(columns_list[i], self.table[column])
            column_type.analyse()
            self.column_types.append(column_type)
        
    def __assign_variable_type(self, column_data: dict, column: pd.Series) -> EmptyVariable | CategoricalVariable | DatetimeVariable | NumericalVariable | StringVariable:
        """Private method.  For a given column, assigns it a variable type based on the column data input.

        Args:
            column_data (dict): Describes the data type of the column.
            column (pandas.Series): Contains the column data.

        Raises:
            ValueError: Thrown when a column is described as having a non-existent type.

        Returns:
            EmptyVariable | CategoricalVariable | DatetimeVariable | NumericalVariable | StringVariable: Column variable type initialised using column data.
        """

        match column_data['Type']:
            case 'empty':
                return EmptyVariable(column)
            case 'numeric':
                return NumericalVariable(
                    column,
                    decimal_precision = column_data['decimal_precision'],
                    average_min_max = column_data['averaged_max_and_min']
                )
            case 'categorical':
                return CategoricalVariable(column)
            case 'datetime':
                if column_data['format']:
                    return DatetimeVariable(
                        column, 
                        datetime_format=column_data['format'],
                        average_min_max = column_data['averaged_max_and_min']
                        )
                else:
                    return DatetimeVariable(column, average_min_max = column_data['averaged_max_and_min'])
            case 'date':
                if column_data['format']:
                    return DatetimeVariable(
                        column, 
                        date_format=column_data['format'],
                        average_min_max = column_data['averaged_max_and_min']
                        )
                else:
                    return DatetimeVariable(column, average_min_max = column_data['averaged_max_and_min'])
            case 'time':
                if column_data['format']:
                    return DatetimeVariable(
                        column, 
                        time_format=column_data['format'],
                        average_min_max = column_data['averaged_max_and_min']
                        )
                else:
                    return DatetimeVariable(column,average_min_max = column_data['averaged_max_and_min'])            
            case 'text':
                return StringVariable(column)
            case _:
                raise ValueError(f"Type of column {column.name} is defined as {column_data['Type']}: this is not an allowed value.")
                